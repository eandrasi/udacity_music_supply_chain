pragma solidity ^0.5.1;

import '../AccessControl/AccessControl.sol';
import '../Core/Ownable.sol';

// Define a contract 'Supplychain'
contract SupplyChain is AccessControl, Ownable {

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;
  
  // Define enum 'State' with the following values:
  enum State 
  { 
    Composed,       // 0
    Recorded,       // 1
    Arranged,       // 2
    WithCover,      // 3
    Published,      // 4
    Distributed,    // 5
    ForSale,        // 6
    Sold            // 7
    }

  State constant defaultState = State.Composed;

//   define a struct for the items sold
  struct ItemsSold {
      address ownerID;
      uint productID;
      uint price;
      uint upc;
  }
// array to hold the sold Albums
  ItemsSold[] soldAlbums;

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Artist, goes on the package, can be verified by the Consumer
    address payable artistID; // Metamask-Ethereum address of the artist
    string  artistName; // Artist Name
    string  artistInformation;  // Artist Information
    uint    productID;  // Product ID potentially a combination of upc + sku
    string  albumName; // Product Notes
    uint    productPrice; // Product Price
    State   itemState;  // Product State as represented in the enum above
    address payable producerID;  // Metamask-Ethereum address of the Distributor
    address payable recordLabelID; // Metamask-Ethereum address of the Retailer
    address payable distributorID; // Metamask-Ethereum address of the Distributor
    address payable consumerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Composed(uint upc);
  event Recorded(uint upc);
  event Arranged(uint upc);
  event WithCover(uint upc);
  event Published(uint upc);
  event Distributed(uint upc);
  event ForSale(uint upc);
  event Sold(uint upc);

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) { 
    require(msg.value >= _price); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc) {
    _;
    uint _price = items[_upc].productPrice;
    uint amountToReturn = msg.value - _price;
    items[_upc].consumerID.transfer(amountToReturn);
  }

  // Define a modifier that checks if an item.state of a upc is Composed
  modifier composed(uint _upc) {
    require(items[_upc].itemState == State.Composed);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Recorded
  modifier recorded(uint _upc) {
    require(items[_upc].itemState == State.Recorded);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Arranged
  modifier arranged(uint _upc) {
    require(items[_upc].itemState == State.Arranged);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is WithCover
  modifier withCover(uint _upc) {
    require(items[_upc].itemState == State.WithCover);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Published
  modifier published(uint _upc) {
    require(items[_upc].itemState == State.Published);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Distributed
  modifier distributed(uint _upc) {
    require(items[_upc].itemState == State.Distributed);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ForSale
  modifier forSale(uint _upc) {
    require(items[_upc].itemState == State.ForSale);
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() public {
    sku = 1;
    upc = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner()) {
      selfdestruct(msg.sender);
    }
  } 
  
  // Every role must register themself with the contract
  function registerArtistID() public {
    addArtist(msg.sender);
  }
  
  // Every role must register themself with the contract
  function registerProducerID() public {
    addProducer(msg.sender);
  }
  
  // Every role must register themself with the contract
  function registerRecordLabelID() public {
    addRecordLabel(msg.sender);
  }

  // Every role must register themself with the contract
  function registerDistributorID() public {
    addDistributor(msg.sender);
  }

  // Define a function 'composeAlbum' that allows an artist to mark an item 'Composed'
  function composeAlbum(uint _upc, address _artistID, string memory _artistName, 
                        string memory _artistInformation, string memory _albumName, 
                        address _producerID) 
                        public
                        verifyCaller(_artistID) 
                        onlyArtist()
  {
    // Upc should exist and be unique
    require(_upc != 0);
    require(items[_upc].upc == 0, "UPC already exists!");

    // ProducerID should not be 0
    require(_producerID != address(0), "address 0 not accepted");

    // producer should be registered as producer
    require(isProducer(_producerID));
    
    // Add the new item
    Item memory newItem;

    newItem.sku = sku;
    newItem.upc = _upc;
    newItem.artistID = msg.sender;
    newItem.artistName = _artistName;
    newItem.artistInformation = _artistInformation;
    newItem.albumName = _albumName;
    newItem.itemState = State.Composed;
    newItem.producerID = address(uint160(_producerID));

    items[_upc] = newItem;

    // Emit the appropriate event
    emit Composed(upc);
  }

  // Define a function 'recordAlbum' that allows a producer to mark an item 'Recorded'
  function recordAlbum(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  composed(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].producerID)
  onlyProducer()
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Recorded;
    
    // Emit the appropriate event
    emit Recorded(_upc);
    
  }

  // Define a function 'arrangeAlbum' that allows a producer to mark an item 'Arranged'
  function arrangeAlbum(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  recorded(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].producerID)
  onlyProducer()
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Arranged;
    
    // Emit the appropriate event
    emit Arranged(_upc);
    
  }

  // Define a function 'createCover' that allows a producer to mark an item 'WithCover'
  function createCover(uint _upc, address _recordLabelID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  arranged(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].producerID)
  onlyProducer()
  {
    // _recordLabelID should not be 0
    require(_recordLabelID != address(0));

    // Update the appropriate fields
    items[_upc].itemState = State.WithCover;
    items[_upc].recordLabelID = address(uint160(address(_recordLabelID)));
    
    // Emit the appropriate event
    emit WithCover(_upc);
    
  }

  // Define a function 'publishAlbum' that allows a producer to mark an item 'Published'
  function publishAlbum(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  withCover(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].recordLabelID)
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Published;
    
    // Emit the appropriate event
    emit Published(_upc);
    
  }

  // Define a function 'distributeAlbum' that allows a producer to mark an item 'Distributed'
  function distributeAlbum(uint _upc, address _distributorID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  published(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].recordLabelID)
  {
    // _distributorID should not be 0
    require(_distributorID != address(0));

    // Update the appropriate fields
    items[_upc].itemState = State.Distributed;
    items[_upc].distributorID = address(uint160(address(_distributorID)));
    // Emit the appropriate event
    emit Distributed(_upc);
    
  }

  // Define a function 'sellItem' that allows a distributor to mark an item 'ForSale'
  function sellItem(uint _upc, uint _productPrice) public 
  // Call modifier to check if upc has passed previous supply chain stage
  distributed(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].distributorID)
  {
    //   require that the price is divisible by 4
    require(_productPrice % 4 == 0, "Price must be divisible by 4");
    // Update the appropriate fields
    items[_upc].productPrice = _productPrice;
    items[_upc].productID = upc * 10000000 + sku;
    items[_upc].itemState = State.ForSale;

    // Increment sku
    sku = sku + 1;
    
    // Emit the appropriate event
    emit ForSale(_upc);
    
  }


  // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
  // Use the above defined modifiers to check if the item is available(distributed), if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyItem(uint _upc) public payable 
    // Call modifier to check if upc has passed previous supply chain stage
    forSale(_upc)
    // Call modifer to check if buyer has paid enough
    paidEnough(items[_upc].productPrice)
    // Call modifer to send any excess ether back to buyer
    checkValue(_upc)
    {
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    // items[_upc].itemState = State.Sold;

    // update the soldAlbums array
    ItemsSold memory newItem;
    newItem.ownerID = msg.sender;
    newItem.productID = items[_upc].productID;
    newItem.price = items[_upc].productPrice;
    newItem.upc = items[_upc].upc;

    soldAlbums.push(newItem);
    // Transfer money to every part involved
    uint toPay = items[_upc].productPrice / 4;

    items[_upc].artistID.transfer(toPay);
    items[_upc].producerID.transfer(toPay);
    items[_upc].recordLabelID.transfer(toPay);
    items[_upc].distributorID.transfer(toPay);
    
    // emit the appropriate event
    emit Sold(_upc);
    
  }

// !!!!!!!!!!!!!!!!Unresolved issue with web3.js//////

  // function sayHello() public view returns (string memory) {
  //   string memory a = "Hello from me";
  //   return a;
  // }

 // Define a function 'fetchItemBufferOne' that fetches the data
  // function fetchAlbumInfo(uint i) public view returns 
  // (
  // string memory albumName
  // ) 
  // {
  // // Assign values to the 8 parameters
  // // Item memory albumToReturn = items[0];

  // string memory a;
  // a = "How do you do?????????????";
  // return a;

  // // return items[1].albumName;
  // // return 
  // // (
  // // albumToReturn.albumName
  // // );
  // }


//  // Define a function 'fetchItemBufferOne' that fetches the data
//   function fetchAlbumInfo(uint _upc) public view returns 
//   (uint    itemSKU,
//   uint    itemUPC,
//   uint    productPrice,
//   address artistID,
//   address producerID,
//   address recordLabelID,
//   address distributorID,
//   string memory artistName,
//   string memory artistInformation,
//   string memory albumName
//   ) 
//   {
//   // Assign values to the 8 parameters
//   Item memory albumToReturn = items[_upc];
//   return 
//   (
//   albumToReturn.sku,
//   albumToReturn.upc,
//   albumToReturn.productPrice,
//   albumToReturn.artistID,
//   albumToReturn.producerID,
//   albumToReturn.recordLabelID,
//   albumToReturn.distributorID,
//   albumToReturn.artistName,
//   albumToReturn.artistInformation,
//   albumToReturn.albumName
//   );
//   }







  // // Define a function 'fetchItemBufferTwo' that fetches the data
  // function fetchItemBufferTwo(uint _upc) public view returns 
  // (
  // uint    itemSKU,
  // uint    itemUPC,
  // uint    productID,
  // string  productNotes,
  // uint    productPrice,
  // uint    itemState,
  // address distributorID,
  // address retailerID,
  // address consumerID
  // ) 
  // {
  //   // Assign values to the 9 parameters
  
    
  // return 
  // (
  // itemSKU,
  // itemUPC,
  // productID,
  // productNotes,
  // productPrice,
  // itemState,
  // distributorID,
  // retailerID,
  // consumerID
  // );
  // }
}